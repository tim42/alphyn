
#include <tools/ct_string.hpp>
#include <tools/demangle.hpp>
#include <alphyn.hpp>
#include <default_token.hpp>

#include <iostream>
#include <tuple>

#include <bnf.hpp>

// a mathematical expression evaluator
struct math_eval_bnf
{
  using return_type = float;
  using token_type = neam::ct::alphyn::bnf::token_type; // the token type generated by the bnf meta-parser

  // attribute names
  static constexpr neam::string_t add_str = "add";
  static constexpr neam::string_t sub_str = "sub";
  static constexpr neam::string_t mul_str = "mul";
  static constexpr neam::string_t div_str = "div";
  static constexpr neam::string_t atof_str = "atof";
  static constexpr neam::string_t forward0_str = "forward:0";
  static constexpr neam::string_t forward1_str = "forward:1";

  static constexpr return_type attr_add(return_type n1, const token_type &, return_type n2) { return n1 + n2; }
  static constexpr return_type attr_sub(return_type n1, const token_type &, return_type n2) { return n1 - n2; }
  static constexpr return_type attr_mul(return_type n1, const token_type &, return_type n2) { return n1 * n2; }
  static constexpr return_type attr_div(return_type n1, const token_type &, return_type n2) { return n1 / n2; }
  static constexpr return_type attr_atof(const token_type &tok)
  {
    float value = 0;
    size_t i = tok.start_index;
    for (; tok.s[i] != '.' && i < tok.end_index; ++i)
      value = value * 10 + (tok.s[i] - '0');
    if (tok.s[i] == '.')
    {
      float cpow = 10;
      for (size_t j = i + 1; j < tok.end_index; ++j)
      {
        value += float(tok.s[j] - '0') / cpow;
        cpow *= 10;
      }
    }

    return value;
  }

  // the attribute list
  using attributes = neam::ct::alphyn::bnf::attribute_db<
    neam::ct::alphyn::bnf::attribute_db_entry<add_str, ALPHYN_ATTRIBUTE(&attr_add)>,
    neam::ct::alphyn::bnf::attribute_db_entry<sub_str, ALPHYN_ATTRIBUTE(&attr_sub)>,
    neam::ct::alphyn::bnf::attribute_db_entry<mul_str, ALPHYN_ATTRIBUTE(&attr_mul)>,
    neam::ct::alphyn::bnf::attribute_db_entry<div_str, ALPHYN_ATTRIBUTE(&attr_div)>,
    neam::ct::alphyn::bnf::attribute_db_entry<atof_str, ALPHYN_ATTRIBUTE(&attr_atof)>,
    neam::ct::alphyn::bnf::attribute_db_entry<forward0_str, neam::ct::alphyn::forward_attribute<0>>,
    neam::ct::alphyn::bnf::attribute_db_entry<forward1_str, neam::ct::alphyn::forward_attribute<1>>
  >;

  // the bnf grammar of the mathematical evaluator
  static constexpr neam::string_t bnf_grammar = R"(
    start ::= sum regexp:'$'              [forward:0];

    sum   ::= prod                        [forward:0]
            | sum '+' prod                [add]
            | sum '-' prod                [sub];

    prod  ::= val                         [forward:0]
            | prod '*' val                [mul]
            | prod '/' val                [div];

    val   ::= regexp:'[0-9]+(\.[0-9]*)?'  [atof]
            | '(' sum ')'                 [forward:1];
  )";
};
// I have to define the bnf_syntax here 'cause I plan to use the on_parse_error::print_message
// error handler and it needs a reference to the string.
constexpr neam::string_t math_eval_bnf::bnf_grammar;

// get the parser, but change its action when an error is found:
using fp_math_class = neam::ct::alphyn::bnf::generate_parser<math_eval_bnf>;
using fp_math_evaluator = neam::ct::alphyn::parser<fp_math_class, neam::ct::alphyn::on_parse_error::print_message>;

int main(int /*argc*/, char **/*argv*/)
{
  // std::cout << "automaton: \n";
  // neam::ct::alphyn::debug_printer<fp_math_class>::print_graph();

  // uncomment the line below to see what nice c++ types are.
  // std::cout << "generated parser: " << neam::demangle<tuple_builder_parser>() << std::endl;
  // std::cout << "generated automaton: " << neam::demangle<neam::ct::alphyn::grammar_tools<tuple_builder_parser>::lr1_automaton>() << std::endl;

  std::string line;
  std::cout << "math-eval > " << std::flush;
  while (std::getline(std::cin, line))
  {
    try
    {
      std::cout << "result: " << fp_math_evaluator::parse_string<float>(line.c_str()) << "\n";
    }
    catch (std::exception &e)
    {
//       std::cerr << "error: " << e.what() << std::endl;
    }
    std::cout << "math-eval > " << std::flush;
  }

  std::cout << std::endl;

  return 0;
}
